# -*- coding: utf-8 -*-
"""Python_excercises.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1T4B7covbLAzcC0rSotV8qCbfEKcYz3V3
"""

### PALINDROME NUMBER #######
class Solution:
    def isPalindrome(self, x: int) -> bool:
        x = str(x)
        y = x[::-1]
        if x==y :
           output = True
        else :
            output = False
        return output

#### MEDIAN OF TWO SORTED ARRAYS #####
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        listx = sorted(nums1+nums2)
        z = len(listx) 
        if (z % 2) == 0 :
            median = (listx[int(z/2)-1]+listx[int(z/2)])/2
        else :
            median = listx[int((z-1)/2)]
        return median

###### LONGEST SUBSTRING WITHOUT REPEATING CHARACTERS ############
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        listx = sorted(nums1+nums2)
        z = len(listx) 
        if (z % 2) == 0 :
            median = (listx[int(z/2)-1]+listx[int(z/2)])/2
        else :
            median = listx[int((z-1)/2)]
        return median

####### CODE SIGNAL ########
# You are given an array of integers a and two integers l and r. You task is to calculate a boolean array b, where b[i] = true if there exists an integer x, such that a[i] = (i + 1) * x and l ≤ x ≤ r. Otherwise, b[i] should be set to false.

# Example

# For a = [8, 5, 6, 16, 5], l = 1, and r = 3, the output should be solution(a, l, r) = [false, false, true, false, true].

# For a[0] = 8, we need to find a value of x such that 1 * x = 8, but the only value that would work is x = 8 which doesn't satisfy the boundaries 1 ≤ x ≤ 3, so b[0] = false.
# For a[1] = 5, we need to find a value of x such that 2 * x = 5, but there is no integer value that would satisfy this equation, so b[1] = false.
# For a[2] = 6, we can choose x = 2 because 3 * 2 = 6 and 1 ≤ 2 ≤ 3, so b[2] = true.
# For a[3] = 16, there is no an integer 1 ≤ x ≤ 3, such that 4 * x = 16, so b[3] = false.
# For a[4] = 5, we can choose x = 1 because 5 * 1 = 5 and 1 ≤ 1 ≤ 3, so b[4] = true.

def solution(numbers, left, right):
    result = [False for i in range(len(numbers))]
    for i in range(len(numbers)):
        x_rest =  numbers[i] % (i+1)
        x = numbers[i] / (i+1)
        print(x, x_rest)
        if x_rest == 0 and (x >= left) and (x <= right) :
            result[i] = True
    return result
# solution([8, 5, 6, 16, 5], 1, 3)

# 
# You are implementing your own programming language and you've decided to add support for merging strings. A typical merge function would take two strings s1 and s2, and return the lexicographically smallest result that can be obtained
# by placing the symbols of s2 between the symbols of s1 in such a way that maintains the relative order of the characters in each string.

# For example, if s1 = "super" and s2 = "tower", the result should be merge(s1, s2) = "stouperwer".

def solution(x,y) :
    x_list = list(x)
    y_list = list(y)
    z = []
    while True :
        i = 0
        if x_list[i] < y_list[i] :
            z.append(x_list[i])
            x_list = x_list[i+1:]
        else :
            z.append(y_list[i])
            y_list = y_list[i+1:]
        if len(x_list) == 0 :
            z.append(y_list[i])
            break
        elif len(y_list) == 0 :
                z.append(x_list[i])
                break  
    return z
#x = 'super'
#y = 'tower'
#solution(x,y)

# You'd like to make your language more unique, so for your merge function, instead of comparing the characters in the usual lexicographical order, 
#you'll compare them based on how many times they occur in their respective initial strings (fewer occurrences means the character is considered smaller). 
#If the number of occurrences are equal, then the characters should be compared in the usual lexicographical way. If both number of occurences and characters are equal, 
#you should take the characters from the first string to the result. Note that occurrences in the initial strings are compared - they do not change over the merge process.

# Given two strings s1 and s2, return the result of the special merge function you are implementing.

# Example 

# For s1 = "dce" and s2 = "cccbd", the output should be
# mergeStrings(s1, s2) = "dcecccbd".
# All symbols from s1 goes first, because all of them have only 1 occurrence in s1 and c has 3 occurrences in s2.

def solution(x,y):
    x_list = list(x)
    y_list = list(y)
    z = []
    while True :
        i = 0
        if x_list.count(x_list[i]) < y_list.count(y_list[i]) :
            z.append(x_list[i])
            x_list = x_list[i+1:]
        elif x_list.count(x_list[i]) > y_list.count(y_list[i]):
            z.append(y_list[i])
            y_list = y_list[i+1:]
        else :
            if x_list[i] < y_list[i] :
                z.append(x_list[i])
                x_list = x_list[i+1:]
            else :
                z.append(y_list[i])
                y_list = y_list[i+1:]    
        if len(x_list) == 0 :
            z = z + y_list[i:]
            break
        elif len(y_list) == 0 :
                z = z + x_list[i:]
                break
    return z
#x = 'dce'
#y = 'cccbd'
#solution(x,y)

# #1
# Given an integer n and an array a of length n, your task is to apply the following mutation to a:

# Array a mutates into a new array b of length n.
# For each i from 0 to n - 1, b[i] = a[i - 1] + a[i] + a[i + 1].
# If some element in the sum a[i - 1] + a[i] + a[i + 1] does not exist, it should be set to 0. For example, b[0] should be equal to 0 + a[0] + a[1].

def solution(a) : # with the array of length n we already got the integer n.
    b = [0 for _ in range(len(a))] 
    a.insert(len(a),0)
    a.insert(0,0)
    for i in range(len(a)-2) :
      b[i] = a[i]+a[i+1]+a[i+2]
    return b
#a = [4, 0, 1, -2, 3]
#solution(a)

'''
Given an array of unique integers numbers, your task is to find the number of pairs of indices (i, j) 
such that i ≤ j and the sum numbers[i] + numbers[j] is equal to some power of 2.
Note: numbers 20 = 1, 21 = 2, 22 = 4, 23 = 8, etc. are considered to be powers of 2
Example
For numbers = [1, -1, 2, 3], the output should be solution(numbers) = 5.
There is one pair of indices where the corresponding elements sum up to 20 = 1:
(1, 2): numbers[1] + numbers[2] = -1 + 2 = 1
There are two pairs of indices where the corresponding elements sum up to 21 = 2:
(0, 0): numbers[0] + numbers[0] = 1 + 1 = 2
(1, 3): numbers[1] + numbers[3] = -1 + 3 = 2
There are two pairs of indices where the corresponding elements sum up to 22 = 4:
(0, 3): numbers[0] + numbers[3] = 1 + 3 = 4
(2, 2): numbers[2] + numbers[2] = 2 + 2 = 4
In total, there are 1 + 2 + 2 = 5 pairs summing up to powers of two.
For numbers = [2], the output should be solution(numbers) = 1.
The only pair of indices is (0, 0) and the sum of corresponding elements is equal to 22 = 4. So, the answer is 1.
For numbers = [-2, -1, 0, 1, 2], the output should be solution(numbers) = 5.
There are two pairs of indices where the corresponding elements sum up to 20 = 1: (2, 3) and (1, 4)
There are two pairs of indices where the corresponding elements sum up to 21 = 2: (2, 4) and (3, 3)
There is one pair of indices where the corresponding elements sum up to 22 = 4: (4, 4)
In total, there are 2 + 2 + 1 = 5 pairs summing up to powers of 2
'''
import math
def solution(numbers) :
    a = 2*max(numbers)
    N = math.floor(math.log(a,2))
    n = 0
    dict_valindx = {}
    for i, val in enumerate(numbers):
        dict_valindx[val] = i
    for z in range(N+1) :
        target = 2**z
        print("z:", z)
        for i, val in enumerate(numbers):
            val = target - numbers[i]
            if (val in dict_valindx) and (i <= dict_valindx[val]) :
                print(i,dict_valindx[val])
                n = n+1
    return n
#numbers = [1, -1, 2, 3]
#solution(numbers)

